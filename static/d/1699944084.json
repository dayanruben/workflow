{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n# Frequently Asked Questions\n\n\n### Isn't this basically React/Elm?\n\n[React](https://reactjs.org/) and [the Elm architecture](https://guide.elm-lang.org/architecture/) were both strong influences for this library. However both those libraries are written for JavaScript. Workflows are written in and for both Kotlin and Swift, making use of features of those languages, and with usability from those languages as a major design goal. There are also a few architectural differences:\n\n|  | React | Elm | Workflow |\n|---|---|---|---|\n| **Modularity** | `Component` | TK | `Workflow` is analogous to React's `Component` |\n| **State** | Each `Component` has a `state` property that is read directly and updated via a `setState` method. | State is called `Model` in Elm. | `Workflow`s have an associated state type. The state can only be updated when the input changes, or with a `WorkflowAction`. |\n| **Views** | `Component`s have a `render` method that returns a tree of elements. | Elm applications have a `view` function that returns a tree of elements. | Since workflows are not tied to any particular UI view layer, they can have an arbitrary rendering type. The `compose()` method returns this type. |\n| **Dependencies** | React allows parent components to pass \"props\" down to their children. | TK | In Swift, `Workflow`s are often structs that need to be initialized with their dependencies and configuration data from their parent. In Kotlin, they have a separate type parameter (`InputT`) that is always passed down from the parent. `Workflow` instances can also inject dependencies, and play nicely with dependency injection frameworks.\n| **Composability** | TK | TK | TK |\n| **Event Handling** | TK | TK | TK |\n\n\n### How do I get involved and/or contribute?\n\n- [Workflow is open source!](https://github.com/square/workflow)\n- See our [CONTRIBUTING](https://github.com/square/workflow/blob/master/CONTRIBUTING.md) doc to get started.\n- Stay tuned! We're considering hosting a public Slack channel for open source contributors.\n\n\n### This seems clever. Can I stick with a traditional development approach?\n\nOf course! Workflow was designed to make complex application architecture predictable and safe for large development teams. We're confident that it brings benefits even to smaller projects, but there is never only one right way to build software. We recommend to [follow good practices and use an architecture that makes sense for your project](https://www.thoughtworks.com/insights/blog/write-quality-mobile-apps-any-architecture).\n\n\n### Why do we need another architecture?\n\nArchitectural patterns with weak access controls and heavy use of shared mutable state make it incredibly difficult to fully understand the behavior of the code that we are writing. This quickly devolves into an arms race as the codebase grows: if every feature or component in the codebase might change anything at any time, bug fixes turn into a really sad game of whack-a-mole.\n\nWe have seen this pattern occur repeatedly in traditional mobile applications using patterns like MVC.\n\nWorkflow defines strong boundaries and contracts between separate parts of the application to ensure that our code remains predictable and maintainable as the size and complexity of the codebase grows.\n","fields":{"slug":"/documentation/faq/"},"headings":[{"value":"Frequently Asked Questions"},{"value":"Isn't this basically React/Elm?"},{"value":"How do I get involved and/or contribute?"},{"value":"This seems clever. Can I stick with a traditional development approach?"},{"value":"Why do we need another architecture?"}],"frontmatter":{"title":"FAQ","index":100}}},{"node":{"rawMarkdownBody":"\n# Concepts\n\nWorkflows provide a way to build complex applications out of small, isolated pieces with a predictable data flow and a consistent API contract. They are conceptually similar to components in architecture patterns such as React (though they are fully native and type-safe).\n\n----\n\n*__Note:__ One important difference between workflows and components found in web frontend frameworks comes from the vast differences between the DOM and native UI paradigms (iOS/Android). The DOM is already declarative (meaning that we can always reason about the element tree in a web page). UIKit, for is not – it very much relies on a procedural programming model where transitions are performed by imperative methods like `push`, `fadeOut`, etc. For this reason, workflows do not ever refer directly to views. They are instead responsible for rendering view models. This view model can then be used to update the UI.*\n\n----\n\n### Workflow is cross-platform\n\nWhile specific APIs differ between Swift and Kotlin, the Workflow library shares all of the same conceptual pieces on both platforms. This is extremely beneficial when building cross-platform software, as the same design (though not the same code) can be used for both Swift and Kotlin. Build a feature on one platform first? That code now serves as an excellent reference when implementing the same functionality on the other platform.\n\n\n## The Role of a Workflow\n\n`Workflow` is a protocol (in Swift) and interface (in Kotlin) that defines the contract for a single node in the workflow hierarchy.\n\n```swift\npublic protocol Workflow: AnyWorkflowConvertible {\n\n    associatedtype State\n\n    associatedtype Output = Never\n\n    associatedtype Rendering\n\n    func makeInitialState() -> State\n\n    func workflowDidChange(from previousWorkflow: Self, state: inout State)\n\n    func compose(state: State, context: WorkflowContext<Self>) -> Rendering\n\n}\n\n```\n\n```kotlin\ninterface Workflow<in I : Any, S : Any, out O : Any, out R : Any> {\n\n  fun initialState(input: I): S\n\n  fun onInputChanged(\n    old: I,\n    new: I,\n    state: S\n  ): S = state\n\n  fun compose(\n    input: I,\n    state: S,\n    context: WorkflowContext<S, O>\n  ): R\n\n  fun snapshotState(state: S): Snapshot\n  fun restoreState(snapshot: Snapshot): S\n\n}\n\n```\n\nWorkflows have several responsibilities:\n\n### Workflows have state\n\nEvery Workflow implementation defines a `State` type to maintain any necessary state while the workflow is running.\n\nFor example, a tic-tac-toe game might have a state like this:\n\n```swift\nstruct State {\n\n    enum Player {\n        case x\n        case o\n    }\n\n    enum Space {\n        case unfilled\n        filled(Player)\n    }\n\n    // 3 rows * 3 columns = 9 spaces\n    var spaces: [Space] = Array(repeating: .unfilled, count: 9)\n    var currentTurn: Player = .x\n}\n```\n\nWhen the workflow is first started, it is queried for an initial state value. From that point forward, the workflow may advance to a new state as the result of events occurring from various sources (which will be covered below).\n\n### Workflows produce an external representation of their state via `Rendering`\n\nImmediately after starting up, or after a state transition occurs, a workflow will have its `compose(state:context:)` method called. This method is responsible for creating and returning a value of type `Rendering`. You can think of `Rendering` as the \"external state\" of the workflow. While a workflow's internal state may contain more detailed or comprehensive state, the `Rendering` (external state) is a type that is useful outside of the workflow.\n\nWhen building an interactive application, the `Rendering` type is commonly (but not always) a view model that will drive the UI layer.\n\n\n### Workflows form a hierarchy (they may have children)\n\nAs they produce a `Rendering` value, it is common for workflows to delegate some portion of that work to a _child workflow_. This is also done via the `ComponentContext` that is passed into the `compose` method. In order to delegate to a child, the parent workflow instantiates the child within the `compose` method. The parent then calls `compose` on the context, with the child workflow as the single argument. The infrastructure will spin up the child workflow (including initializing its initial state) if this is the first time this child has been used, or, if the child was also used on the previous `compose` pass, the existing child will be updated. Either way, `compose` will ultimately be called on the child (by the Workflow infrastructure), and the resulting `Child.Rendering` value will be returned to the parent.\n\nThis allows a parent to return complex `Rendering` types (such as a view model representing the entire UI state of an application) without needing to model all of that complexity within a single workflow.\n\n\n### Workflows can respond to UI events\n\nThe `WorkflowContext` that is passed into `compose` as the second parameter provides some useful tools to assist in creating the `Rendering` value. \n\nIf a workflow is producing a view model, it is common to need an event handler to respond to UI events. The `WorkflowContext` has API to create an event handler that, when called, will advance the workflow by dispatching an action back to the workflow.\n\n\n### Workflows can subscribe to external event sources\n\nIf a workflow needs to respond to some external event source (e.g. push notifications), the workflow can ask the context to listen to those events from within the `compose` method.\n\n\n### Workflows can perform asynchronous tasks (Workers)\n\n`Workers` are very similar in concept to child workflows. Unlike child workflows, however, workers do not have a `Rendering` type; they only exist to perform a single asynchronous task before sending an output event back up the tree to their parent.\n\nA workflow can ask the infrastructure to await the result of a worker by handing that worker to the context within a call to the `compose` method.\n\n### Workflows are advanced by `Action`s\n\nAny time something happens that should advance a workflow – a UI event, a network response, a child's output event – actions are used to perform the update. For example, a workflow may respond to UI events by mapping those events into a type conforming to `WorkflowAction`. These types implement the logic to advance a workflow by:\n- Advancing to a new state\n- (Optionally) emitting an output event up the tree.\n\n\n### Workflows can emit output events up the hierarchy to their parent\n\nWhen a workflow is advanced by an action, an optional output event can be sent up the workflow hierarchy. This is the opportunity for a workflow to notify its parent that something has happened (and the parent's opportunity to respond to that event by dispatching its own action, continuing up the tree as long as output events are emitted).","fields":{"slug":"/documentation/concepts/"},"headings":[{"value":"Concepts"},{"value":"Workflow is cross-platform"},{"value":"The Role of a Workflow"},{"value":"Workflows have state"},{"value":"Workflows produce an external representation of their state via Rendering"},{"value":"Workflows form a hierarchy (they may have children)"},{"value":"Workflows can respond to UI events"},{"value":"Workflows can subscribe to external event sources"},{"value":"Workflows can perform asynchronous tasks (Workers)"},{"value":"Workflows are advanced by Actions"},{"value":"Workflows can emit output events up the hierarchy to their parent"}],"frontmatter":{"title":"Concepts","index":1}}},{"node":{"rawMarkdownBody":"\n# Workflow Documentation\n\n\n### This section provides an overview of the Workflow library and the tools that you will use to build your features and products.\n\nWorkflow is a library for building applications in a simple, consistant shape.\n\n\n```\n┌────────────────────────────┐                    ┌────────────────────────────┐\n│                            │                    │                            │\n│                            │                    │                            │\n│                            │                    │                            │\n│                            │  ◀ ─ ─ ─ ─ ─ ─ ─   │                            │\n│                            │                    │                            │\n│         Workflows          │  ◀ ─ ─ ─ ─ ─ ─ ─   │                            │\n│                            │                    │                            │\n│                            │  ◀ ─ ─ ─ ─ ─ ─ ─   │             UI             │\n│                            │                    │                            │\n│                            │      Events        │                            │\n│                            │                    │                            │\n└────────────────────────────┘                    │                            │\n              │                                   │                            │\n              ▼                                   │                            │\n       ┌─────────────┐                            │                            │\n       │ View Models │                            │                            │\n       └─────────────┘                            └────────────────────────────┘\n              │                                                  ▲              \n              ▼                                                  │              \n┌──────────────────────────────────────────────────────────────────────────────┐\n│                                                                              │\n│                                  Container                                   │\n│                                                                              │\n└──────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Workflows\n\nThe Workflows at the left of the diagram contain all state and business logic for the application. This is where network requests happen, navigation decisions are made, models are saved to or loaded from disk – if it's not UI, it's in this box.\n\n### View Models\n\nThe primary job of the Workflows is to emit an observable stream of view models representing the current state of the application's UI. You will sometimes hear these view models referred to as 'screens', which is just another way to refer to a view model that contains the data for an entire screen in the app.\n\n### Container\n\nThe container is responsible for plumbing together the two separate halves of the application. It subscribes to the stream of view models that the workflows provide, then implements the logic to update the live UI whenever a new view model is emitted.\n\n### UI\n\nThis is typically conventional platform-specific UI code. One important note is that UI code should never attempt to navigate using system components (navigation controller pushes, modal presentation, etc). In this architecture the workflows are in charge – any navigation that happens outside of the workflow will be disregarded and stomped on during the next update cycle.\n\n### Events\n\nIn order for the application to actually do anything, the workflow needs to receive events from the UI. When the user interacts with the application by, for example, tapping a button, the workflow receives that event – which may trigger a simple state transition, or more complex behavior such as a network request.\n","fields":{"slug":"/documentation/"},"headings":[{"value":"Workflow Documentation"},{"value":"This section provides an overview of the Workflow library and the tools that you will use to build your features and products."},{"value":"Workflows"},{"value":"View Models"},{"value":"Container"},{"value":"UI"},{"value":"Events"}],"frontmatter":{"title":"Workflow Documentation","index":0}}},{"node":{"rawMarkdownBody":"\n# Kotlin\n\n_Coming soon_","fields":{"slug":"/documentation/kotlin/"},"headings":[{"value":"Kotlin"}],"frontmatter":{"title":"Kotlin","index":4}}},{"node":{"rawMarkdownBody":"\n# Adding Workflow to a project\n\nThis document will guide you through the process of adding Workflow to an iOS project.\n\n\n## Libraries\n\nYou'll need the following four libraries:\n\n```swift\nimport Workflow\nimport WorkflowUI\nimport ReactiveSwift\nimport Result\n```\n\nThe easiest way to integrate these libraries is via Cocoapods. If you are using Cocoapods, you can simply add the dependencies to your `.podspec`.\n\n```ruby\n# MySoftware.podspec\nPod::Spec.new do |s|\n    # ...\n\n    s.dependency 'Workflow'\n    s.dependency 'WorkflowUI'\n    s.dependency 'ReactiveSwift'\n    s.dependency 'Result'\n\n    # ...\nend\n```\n","fields":{"slug":"/documentation/swift/adding-workflow-to-a-project/"},"headings":[{"value":"Adding Workflow to a project"},{"value":"Libraries"}],"frontmatter":{"title":"Adding Workflow to a project","index":2}}},{"node":{"rawMarkdownBody":"\n# Building a View Controller from a Screen\n\nNow that we have a workflow, we need a way to map our screen to an actual view controller.\n\n\n## `ScreenViewController`\n\nThe `ScreenViewController` provides a baseclass the hides the plumbing of updating a view controller from a view model update.\n\n```swift\nstruct DemoScreen: Screen {\n    let title: String\n    let onTap: () -> Void\n}\n\n\nclass DemoScreenViewController: ScreenViewController<SimpleScreen> {\n\n    private let button: UIButton\n\n    required init(screen: SimpleScreen, viewRegistry: ViewRegistry) {\n        button = UIButton()\n        super.init(screen: screen, viewRegistry: viewRegistry)\n\n        update(screen: screen)\n    }\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        button.addTarget(self, action: #selector(buttonPressed(sender:)), for: .touchUpInside)\n\n        view.addSubview(button)\n    }\n\n    override func viewWillLayoutSubviews() {\n        super.viewWillLayoutSubviews()\n\n        button.frame = view.bounds\n    }\n\n    override func screenDidChange(from previousScreen: SimpleScreen) {\n        super.screenDidChange(from: previousScreen)\n        update(screen: screen)\n    }\n\n    private func update(screen: SimpleScreen) {\n        button.setTitle(screen.title, for: .normal)\n    }\n\n    @objc private func buttonPressed(sender: UIButton) {\n        screen.onTap()\n    }\n\n}\n```\n","fields":{"slug":"/documentation/swift/building-a-view-controller-from-screen/"},"headings":[{"value":"Building a View Controller from a Screen"},{"value":"ScreenViewController"}],"frontmatter":{"title":"Building a View Controller from a Screen","index":5}}},{"node":{"rawMarkdownBody":"\n# Building a Workflow\n\n\n## Introduction\n\nA simple workflow looks something like this:\n\n```swift\nstruct DemoWorkflow: Workflow {\n\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n\n}\n\nextension DemoWorkflow {\n\n    struct State {}\n\n    func makeInitialState() -> State {\n        return State()\n    }\n\n    func workflowDidChange(from previousWorkflow: DemoWorkflow, state: inout State) {\n\n    }\n    \n    func compose(state: State, context: WorkflowContext<DemoWorkflow>) -> String {\n        Return \"Hello, \\(name)\"\n    }\n\n}\n```\n\nA type conforming to `Workflow` represents a single node in the workflow tree. It should contain any values that must be provided by its parent (who is generally responsible for creating child workflows).\n\nConfiguration parameters, strings, network services… If your workflow needs access to a value or object that it cannot create itself, they should be passed into the workflow's initializer.\n\nEvery workflow defines its own `State` type to contain any data that should persist through subsequent compose passes.\n\n## Compose\n\nWorkflows are only useful when they render a value for use by their parent (or, if they are the root workflow, for display). This type is very commonly a view model, or `Screen`. The `compose(state:context:)` method has a couple of parameters, so we’ll work through them one by one.\n\n```swift\nfunc compose(state: State, context: WorkflowContext<DemoWorkflow>) -> Rendering\n```\n\n### `state`\n\nContains a value of type `State` to provide access to the current state. Any time the state of workflow changes, `compose` is called again to take into account the change in state.\n\n### `context`\n\nThe workflow context:\n- provides a way for a workflow to defer to nested (child) workflows to generate some or all of its rendered output. We’ll walk through that process later on when we cover composition.\n- allows a workflow to request the execution of asynchronous tasks (`Worker`s)\n- generates event handlers for use in constructing view models.\n\nIn order for us to see the anything in our app, we'll need to return a `Screen` that can be turned into a view controller:\n\n```swift\n    func compose(state: State, context: WorkflowContext<DemoWorkflow>) -> Screen {\n        return DemoScreen(title: \"A nice title\")\n    }\n```\n\n## Actions, or “Things that advance a workflow”\n\nSo far we have only covered workflows that perform simple tasks like generate strings or simple screens with no actions. If our workflows take on a complicated roles like generating view models, however, they will inevitably be required to handle events of some kind – some from UI events such as button taps, others from infrastructure events such as network responses.\n\nIn conventional UIKit code, it is common to deal with each of those event types differently. The common pattern is to implement a method like `handleButtonTap(sender:)`. Workflows are more strict about events, however. Workflows require that all events be expressed as \"Workflow Actions.\"\n\nThese actions should be thought of as the entry point to your workflow. If any action of any kind happens (that your workflow cares about), it should be modeled as an action.\n\n```swift\nstruct DemoWorkflow: Workflow {\n    /// ...\n}\n\nenum Action: WorkflowAction {\n\n    typealias WorkflowType = DemoWorkflow\n\n    case refreshButtonTapped /// UI event\n    case refreshRequestFinished(RefreshResponse) /// Network event\n\n    func apply(toState state: inout DemoWorkflow.State) -> DemoWorkflow.Output? {\n        /// ...\n    }\n}\n```\n\n## The Update Cycle\n\nEvery time a new action is received, it is applied to the current state of the workflow. If your workflow does more than simply render values, the action's `apply` is the method where the logic lives.\n\nThere are two things that the `apply(toState:)` method is responsible for:\n- Transitioning state\n- (Optionally) emitting an output event\n\nNote that the `compose(state:context:)` method is called after every state change, so you can be sure that any state changes will be reflected.\n\nSince we have a way of expressing an event from our UI, we can now use the callback on our view model to send that event back to the workflow:\n\n```swift\nfunc compose(state: State, context: WorkflowContext<DemoWorkflow>) -> Screen {\n    return DemoScreen(\n        title: \"A nice title\",\n        onTap: context.makeEventHandler(action: Action.refreshButtonTapped)\n}\n```\n\n## State\n\nSome workflows do not need state at all – they simple render values based on the values they were initialized with. But for more complicated workflows, state management is critical. For example, a multi-screen flow only functions if we are able to define all of the possible steps (model the state), remember which one we are currently on (persist state), and move to other steps in the future (transition state).\n\nTo define your workflow's state, simply implement the associatedtype `State` via an enum or struct.\n\n```swift\nstruct WelcomeFlowWorkflow: Workflow {\n\n    enum State {\n        case splashScreen\n        case loginFlow\n        case signupFlow\n    }\n\n    enum Action: WorkflowAction {\n        case back\n        /// ...\n    }\n\n    /// ...\n}\n```\n\n*__Note:__ Workflows (and their `State`) should always be implemented through value types (structs and enums) due to the way the framework handles state changes. This means that you can never capture references to `self`, but the consistent flow of data pays dividends – try this architecture for a while and we are confident that you will see the benefits.*\n\n## Workers\n\nWorkers provide a declarative interface to units of asyncronous work (such as network requests).\n\n## Output Events\n\nThe last role of the update cycle is to emit output events. As workflows form a hierarchy, it is common for children to send events up the tree. This may happen when a child workflow finishes or cancels, for example.\n\nWorkflows can define an output type, which may then be returned by Actions.\n\n\n## Composition\n\nComposition is the primary tool that we can use to manage complexity in a growing application. Workflows should always be kept small enough to be understandable – less than 150 lines is a good target. By composing together multiple workflows, complex problems can be broken down into individual pieces that can be quickly understood by other developers (including future you).\n\nThe context provided to the `compose(state:context:)` method defines the API through which composition is made possible.\n\n### The Workflow Context\n\nThe useful role of children is ultimately to provide rendered values (typically screen models) via their `compose(state:context:)` implementation. To obtain that value from a child workflow, the 'render(_ workflow:key:)` method is invoked on the render context.\n\nWhen a workflow is passed into the context’s render method, the context will do the following:\n- Check if the child workflow is new or existing:\n - If a workflow with the same type was used during the last render pass, the existing child workflow will be updated with the new workflow.\n - Otherwise, a new child workflow node will be initialized.\n- The child workflow's `compose(state:context:)` method is called.\n- The rendered value is returned.\n\nIn practice, this looks something like this:\n\n```swift\nstruct ParentWorkflow: Workflow {\n\n    func compose(state: State, context: WorkflowContext<ParentWorkflow>) -> String {\n        let childWorkflow = ChildWorkflow(text: \"Hello, World\")\n        return context.render(childWorkflow) /// returns \"dlroW ,olleH\"\n    }\n\n}\n\nstruct ChildWorkflow: Workflow {\n\n    var text: String\n\n    // ...\n\n    func compose(state: State, context: WorkflowContext<ChildWorkflow>) -> String {\n        return String(text.reversed())\n    }\n}\n```\n","fields":{"slug":"/documentation/swift/building-a-workflow/"},"headings":[{"value":"Building a Workflow"},{"value":"Introduction"},{"value":"Compose"},{"value":"state"},{"value":"context"},{"value":"Actions, or “Things that advance a workflow”"},{"value":"The Update Cycle"},{"value":"State"},{"value":"Workers"},{"value":"Output Events"},{"value":"Composition"},{"value":"The Workflow Context"}],"frontmatter":{"title":"Building a Workflow","index":3}}},{"node":{"rawMarkdownBody":"\n# Swift\n\nThe Workflow infrastructure is split into several modules.\n\n### `Workflow`\n\nThe `Workflow` library contains the core types that are used to implement state-driven workflows, including the `Workflow` protocol and related indrastructure.\n\n### `WorkflowUI`\n\nContains the basic infrastructure required to build a Workflow-based application that uses `UIKit`.\n\n---\n\nWorkflow for iOS makes extensive use of [ReactiveSwift](https://github.com/ReactiveCocoa/ReactiveSwift). If you are new to reactive programming, you may want to familiarize yourself with some of the basics. Workflow takes care of a lot of the reactive plumbing in a typical application, but you will have a better time if you understand what the framework is doing.\n- [Core Reactive Primitives](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Documentation/ReactivePrimitives.md)\n- [Basic Operators](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Documentation/BasicOperators.md)\n- [How does ReactiveSwift relate to RxSwift?](https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Documentation/RxComparison.md)","fields":{"slug":"/documentation/swift/"},"headings":[{"value":"Swift"},{"value":"Workflow"},{"value":"WorkflowUI"}],"frontmatter":{"title":"Swift","index":3}}},{"node":{"rawMarkdownBody":"\n# Tooling\n\n\n----\n\n## Xcode templates\n\nWorkflow comes with a set of file templates to simplify the process of building features. After installation, these templates can be found via `File > New > New File...` in Xcode.\n\n1. Launch terminal and navigate to the Workflow source directory.\n2. Run `./Tooling/Templates/install-xcode-templates.sh`.\n3. Restart Xcode.","fields":{"slug":"/documentation/swift/tooling/"},"headings":[{"value":"Tooling"},{"value":"Xcode templates"}],"frontmatter":{"title":"Tooling","index":2}}},{"node":{"rawMarkdownBody":"\n# Using a workflow to show UI\n\n\n## `ContainerViewController`\n\nIn the Workflow architecture, the container acts as the glue between the state-driven world of Workflows and the UI that is ultimately displayed. On iOS, the container is implemented as `ContainerViewController`.\n\n```swift\n\n/// Binds a root workflow to a renderable view controller.\npublic final class ContainerViewController<Output>: UIViewController {\n\n    /// Emits output events from the bound workflow.\n    public let output: Signal<Output, NoError>\n\n    public init<WorkflowType>(workflow: WorkflowType, viewRegistry: ViewRegistry) where WorkflowType: Workflow, WorkflowType.Output == Output\n\n}\n\n```\n\nThe first initializer argument is the workflow that will drive your application.\n\nThe second initializer argument is the view registry. The view registry acts as a mapping between the view models (`Screen`s) that your workflow emits and the concrete UI implementations that should be used to display them.\n\n```swift\nimport UIKit\nimport Workflow\nimport WorkflowUI\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        let window = UIWindow(frame: UIScreen.main.bounds)\n\n        var viewRegistry = ViewRegistry()\n\n        let container = ContainerViewController(\n            workflow: DemoWorkflow(),\n            viewRegistry: viewRegistry)\n\n        window.rootViewController = container\n        self.window = window\n        window.makeKeyAndVisible()\n        return true\n    }\n}\n\n```\n\nYour project should compile at this point. It will crash as soon as the workflow emits a screen, however, because we have not registered any UI implementations with the view registry. Let's fix that:\n\n```swift\nlet workflow: Workflow<Screen, Never> = /// Instantiate a workflow\n\nvar viewRegistry = ViewRegistry()\n\nviewRegistry.register(screenViewControllerType: DemoScreenViewController.self)\n\nlet container = ContainerViewController(\n    workflow: DemoWorkflow(),\n    viewRegistry: viewRegistry)\n```\n","fields":{"slug":"/documentation/swift/using-a-workflow-for-ui/"},"headings":[{"value":"Using a workflow to show UI"},{"value":"ContainerViewController"}],"frontmatter":{"title":"Using a Workflow to Show UI","index":6}}}]}}}